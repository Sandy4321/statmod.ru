<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/index.xsl"?>
<!DOCTYPE html SYSTEM "/contents.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<link href="/statmod.css" rel="stylesheet" type="text/css"/>
		<title>Программирование: C#. Первое впечатление</title>
	</head>
	<body>
		<h2>
			<b>C#</b>. Первое впечатление
		</h2>
		<ul>
			<li>
				<a href="#diff">Отличия от <b>C++</b>
				</a>
			</li>
			<li>
				<a href="#classes">Классы и Структуры</a>
			</li>
			<li>
				<a href="#interfaces">Интерфейсы</a>
			</li>
			<li>
				<a href="#properties"> Свойства </a>
			</li>
			<li>
				<a href="#delegatesnevents">Делегаты и События</a>
			</li>
			<li>
				<a href="#clr">Common Language Runtime</a>
			</li>
		</ul>
		<p>
      Объектом данного сочинения является язык программирования <b>C#</b>. Я опишу
      первое впечатление от знакомства с ним. Основой для этого сделаю сравнение с <b>C++</b>.
      Не только и не столько потому, что эти языки похожи, а в силу того,
      что на данный момент лучше всего я знаком с <b>C++</b> и обладаю некоторым опытом
      в разработке программ именно на последнем. Кроме того, иногда я буду ссылаться
      на <b>Java</b>, на который <b>C#</b> похож не меньше, а то и больше, чем на <b>C++</b>.
    </p>
		<p>
			<b>C#</b> является объектно-ориентированным языком в стиле <b>C++</b>. Спецификацию
      этого языка можно найти в MSDN. В нем, в дополнение к встроенным типам, также используются
      встроенные интерфейсы для поддержки некоторых важных методов программирования.
      Синтаксис <b>C#</b> требует от программиста более четко указывать свои намерения,
      чем синтаксис <b>C++</b>, унаследованный последним от чистого <b>C</b>.
      Стоит отметить, что популярность языка во многом зависит от наличия тех или иных библиотек.
      <b>C#</b> ориентирован на использование на платформе .NET, для которой имеются
      обширный библиотеки разных классов. Я же сосредоточусь на самом языке,
      безотносительно этих библиотек, а именно, на некоторых идеологических основах и
      базовых конструкциях языка.
    </p>
		<h3>
			<a name="diff">Отличия от <b>C++</b>
			</a>
		</h3>
		<p>
      Хотелось бы начать с одного из основных отличий <b>C#</b> от <b>C++</b>, дающего
      начало ряду основных возможностей языка. А именно, если программа, написанная на
      <b>C++</b>, компилятором и компоновщиком преобразуется в машинный код конкретной
      платформы, то программа на <b>C#</b> компилируется в промежуточный <b>MSIL</b>
      (Microsoft Intermediate Language) код. И уже этот <b>MSIL</b> код позже преобразуется
      в код под конкретную платформу. Причем это может происходить в любой момент, от получения
      кода до запуска приложения. Это относится не столько к <b>C#</b>, сколько к <b>CLR</b>
      (Common Language Runtime), среде исполнения <b>MSIL</b> кода, поэтому здесь я не буду
      останавливаться, а подробнее об этом можно узнать
      в <a href="#clr">соответствующем разделе <b>CLR</b>
			</a>.
    </p>
		<p>
      Использование абстрактной машины для <b>C#</b> приводит к необходимости отдельно
      разбираться с управлением памятью. В <b>C#</b> (и <b>CLR</b> в целом) для этой цели
      используется <span class="interesting">сборщик мусора (garbage collector)</span>.
      Аналогичное решение используется и в <b>Java</b>. Преимущество такого подхода, кроме
      разных способов работы с памятью на разных платформах, заключается еще и в отсутствии
      необходимости явного выделения и освобождения памяти программистом. Сборка мусора
      осуществляется либо в моменты простоя программы (когда она ожидает команд пользователя),
      либо по мере необходимости в свободной памяти (сборку мусора можно вызвать и в коде).
      Сборщик мусора отслеживает состояние объектов &mdash; ссылается ли на них кто-нибудь
      или нет. Если он находит изолированную (от остальной программы) группу объектов,
      то он запускает процедуру освобождения занимаемой ими памяти. Здесь детально это
      рассматривать я не буду. К сожалению, помимо плюсов у сборки мусора есть и минусы.
      Первый &mdash; это снижение быстродействия, отслеживание состояния объектов отнюдь
      не ускоряет работу программы. Второе &mdash; потеря ясности в том, когда происходит
      удаление объектов (вызов деструктора в смысле <b>C++</b>). Помимо этого, это усложняет
      использование одной из методологий ООП, когда в конструкторе объекта происходит
      захват ресурса, а в деструкторе происходит его освобождение. Данный метод удобен
      и эффективен в плане уменьшения количества ошибок, так как вызов парного метода
      происходит автоматически. Разработчики <b>C#</b> сочли этот метод настолько эффективным
      и удобным, что он поддерживается на уровне языка &mdash; посредством реализации
      интерфейса <b>IDisposable</b>. (<b>Java</b> такого механизма не имеет.)
    </p>
		<p>
      Стоит отметить, что в <b>C#</b> очень большое внимание уделяется безопасности кода.
      Это выражается в запрещении потенциально некорректных операций. В случае же невозможности
      запретить операцию такого рода (например, приведение типов), проверка на ошибки
      осуществляется динамически и в случае ее возникновения выбрасывается соответствующее
      исключение. Такой подход приводит к уменьшению возможностей языка. В <b>C#</b> выход
      из этой ситуации заключается в использовании <a href="#interfaces">интерфейсов</a>,
      поддержанных на уровне языка. Примером такого интерфейса может служить уже упоминавшийся
      <b>IDisposable</b> (в данном случае сборку мусора можно рассматривать как решение
      проблем с управлением памятью).
    </p>
		<p>
      <a href="#top">Вернуться в начало</a>
		</p>
		<h3>
			<a name="classes">Классы и Структуры (Classes and Structures)</a>
		</h3>
		<p>
      Как и в <b>C++</b>, классы и структуры являются основными рабочими объектами языка.
      Эти две конструкции языка представляют одинаковые понятия, за исключением одного
      свойства. Переменные структур являются типами-значениями, а классов &mdash; типами-ссылками.
      То есть присвоение одной структуры другой вызывает операцию копирования содержимого
      одной из них в другую, а после присвоения переменной типа класса другой приводит
      к тому, что обе они ссылаются на один объект.
    </p>
		<p>
      Подобно классам в <b>C++</b>, классы в <b>C#</b> могут содержать методы и поля.
      Кроме того, классы могут содержать некоторые другие конструкции языка, такие,
      как <a href="#delegatesnevents">события</a> и <a href="#properties">свойства</a>.
      У класса может быть только один базовый класс, вернее &mdash; всегда один, так как если
      класс не наследует никакие пользовательские классы, то он неявно наследуется
      от базового класса <b>object</b>. В то же время, <b>C#</b> допускает реализацию
      нескольких <a href="#interfaces">интерфейсов</a> в одном классе.
    </p>
		<p>
      Все сказанное о классах справедливо и для структур, за исключением наследования.
      В отличие от классов все структуры неявно наследуются от типа <b>ValueType</b>,
      а наследование от самих структур запрещено. При этом структуры, как и классы, могут
      реализовывать один или несколько интерфейсов.
    </p>
		  <a href="#top">Вернуться в начало</a>
		<h3>
			<a name="interfaces">Интерфейсы (Interfaces)</a>
		</h3>
		<p>
      В целом весь <b>C#</b> ориентирован на использование интерфейсов. В нем интерфейсы
      представлены отдельной структурой языка. Интерфейс объявляется с ключевым словом
      <b>interface</b> и является почти такой же структурой языка,
      как и <a href="#classes">класс</a>, за несколькими исключениями.
    </p>
		<p>
      В отличие от класса интерфейс не может содержать полей. Интерфейс может содержать
      все остальные конструкции языка, которые могут содержаться в классе. Такие, как
      свойства, события и методы. Стоит отметить, что интерфейс не может содержать
      определений методов, свойств или событий. В терминах <b>C++</b> интерфейс представляет
      собой абстрактный класс. Все методы интерфейса должны быть реализованы в классах,
      наследующих данный интерфейс.
    </p>
		<p>
      Отказ от использования полей в интерфейсе позволяет поддерживать множественное
      наследование от интерфейсов, в то время как наличие полей в классах препятствует
      множественному наследованию классов. Такой подход можно рассматривать как вполне
      разумное сокращение возможностей <b>C++</b>. При множественном наследовании классов
      возникает много проблем, как у разработчиков компиляторов, так и у рядовых программистов.
      Разработчикам компиляторов необходимо заботиться о правильном размещении таких классов
      в памяти и передавать указатели на базовые классы, плюс необходимо принимать не самые
      простые решения в случае виртуального наследования. У остальных программистов возникают
      проблемы в случае наследования от классов, наследующих один базовый, да и в некоторых
      других тоже. Разрешение множественного наследования только от интерфейсов позволяет избежать
      этих проблем.
    </p>
		<p>
      В <b>Java</b> интерфейс имеет подобную смысловую нагрузку и подобные свойства. Кроме
      этого, в <b>Java</b> для наследования от интерфейсов введено специальное ключевое
      слово <span class="interesting">implements (реализовывает)</span>, которое достаточно
      точно характеризует смысл такого отношения между классом и интерфейсом. Интерфейс
      определяет <span class="interesting">контракт работы классов</span>, его реализующих,
      а классы обязаны его выполнить-реализовать.
    </p>
		  <a href="#top">Вернуться в начало</a>
		<h3>
			<a name="properties">Свойства (Properties)</a>
		</h3>
		<p>
      В <b>C#</b> представлена интересная идея свойств объекта. С точки зрения пользователя
      класса свойства представляют собой обычное поле, в то время как внутри класса каждое
      свойство представляется методами доступа, так называемыми <b>getter</b>’ом и/или
      <b>setter</b>’ом. Геттер и сеттер представляют пару методов для чтения/записи данных.
      В зависимости от типа поля, у свойства может быть только один такой метод (read-only &mdash;
      только для чтения, write-only &mdash; только для записи) или оба (read-write &mdash; чтение
      и запись). Каждый из методов является безымянным, то есть вызов каждого из них происходит
      только неявно, через обращение к свойству.
    </p>
		<p>
      <a href="#top">Вернуться в начало</a>
		</p>
		<h3>
			<a name="delegatesnevents">Делегаты и События (Delegates and Events)</a>
		</h3>
		<p>
      Часто в процессе написания метода возникает необходимость вызвать другой метод,
      неизвестный в этом, а определяемый в месте вызова
      (или определяемый ранее в процессе выполнения программы).
      Обычно это бывает необходимо для обработки объектов в коллекциях, например,
      получения какой-либо информации из них, или получения информации в процессе выполнения
      долгой операции. В <b>C++</b> это можно сделать двумя способами: использовать специально
      определенный интерфейс (наследуя от него конкретные классы и реализовывая необходимые методы),
      или <b>callback</b>, обычно это указатель на функцию.
      И если в <b>C#</b> первый способ вполне уместен и поддерживается,
      то второй потенциально опасен. Поэтому для поддержки второго способа в язык были
      введены делегаты. Делегаты представляют из себя абстракцию указателя на функцию.
      Тип делегата определяется сигнатурой метода, который может быть вызван через каждый
      конкретный экземпляр. Делегат можно использовать, как обычную переменную.
      Вызов делегата синтаксически такой же, как и вызов обычной функции.
    </p>
		<p>
      Другой проблемой, решаемой с помощью делегатов, является передача информации об изменении
      одного объекта другому объекту без необходимости установления непосредственной связи
      между ними. Эта проблема появляется достаточно часто при связи различных компонент,
      когда изменение одной опосредованно должно отразиться на другой. Особенно часто такая проблема
      возникает при реализации пользовательского интерфейса, где интерфейсные классы (различные
      окна (windows) и редакторы (editors)) достаточно сильно взаимодействуют с кодом,
      обрабатывающим данные. Для данной проблемы характерны условия, в которых объектов,
      получающих уведомления об изменениях, несколько, а их состав может меняться динамически.
      В таком случае необходимо иметь коллекцию делегатов, которая поддержана в языке в виде
      Событий. События поддерживают добавление и удаление делегатов, а также вызов последних
      с конкретными параметрами. Уведомление о событии (вызов всех добавленных делегатов)
      выглядит, как вызов обычной функции. Стоит отметить, что Событие может быть вызвано
      только из класса, где оно определено.
    </p>
		<p>
      <a href="#top">Вернуться в начало</a>
		</p>
		<h3>
			<a name="clr">Common Language Runtime</a>
		</h3>
		<p>
      Программа, написанная на <b>C++</b>, сначала компилируется в набор отдельных компонент,
      которые потом связываются (link) компоновщиком (linker) в программу (или отдельную
      компоненту) предназначенную для работы на машине с определенной архитектурой и операционной
      системой. Промежуточные результаты в большинстве случаев никого не интересуют. Проект
      на <b>C#</b> компилируется сразу в готовый модуль на «промежуточном» бинарном языке
      <b>MSIL</b> (Microsoft Intermediate Language). В первую очередь <b>MSIL</b> предназначен
      для абстракции объектно-ориентированного кода, написанного на конкретном языке для
      конкретной платформы. В идеале это позволяет скомпилированный код запускать на любой
      машине.
    </p>
		<p>
		  Такое решение не было новым. Еще раньше в основу <b>Java</b> была положена та же идея &mdash;
		  запуск единожды собранной программы на любой платформе. И для работы готовой программы,
		  написанной на <b>Java</b>, необходимо иметь только платформу с установленной виртуальной
		  машиной <b>Java</b> (Java Virtual Machine) (в байт-код для которой как раз и компилируется
		  исходный код программы). Первые реализации виртуальной машины <b>Java</b> представляли
		  собой интерпретаторы, на лету исполняя байт-код. Однако такой подход оказался чреват
		  сильной потерей производительности (что и понятно &mdash; эмулирование работы одной машины
		  на другой скорости не добавляет). Поэтому через какое-то время появились новые реализации
		  JVM, перед запуском компилировавшие байт-код в родной («нативный», native) для конкретной
		  машины код. Такой подход называется <span class="interesting">Just-In-Time</span> компиляцией,
		  то есть компиляцией во время исполнения.
    </p>
    <p>
      При разработке <b>MSIL</b> были учтены эти проблемы. Поэтому <b>MSIL</b> программа
      работает в среде <b>CLR</b> (Common Language Runtime), и перед запуском исходный
      <b>MSIL</b> код компилируется в родной код конкретной платформы. Сейчас обычно это делается
      сразу после генерации <b>MSIL</b> кода, но это может происходить и в момент установки
      программы, или непосредственно перед первым запуском. При этом последние два варианта
      могут дать ускорение производительности программы, так как в момент инсталляции
      (или первого запуска программы) уже известны все особенности платформы, на которой будет
      работать программа, и компилятор «нативного» кода может воспользоваться этим для оптимизации
      программы. Естественно, что такого рода действия конечная платформа должна поддерживать.
    </p>
		<p>
      Сейчас <b>CLR</b> поддерживается в трех версиях платформы .NET под Windows: 1.0, 1.1,
      2.0. Программы под них можно писать на Microsoft Visual Studio версий
      .NET&nbsp;(7.0), 2003&nbsp;(7.1), 2005&nbsp;(8.0) соответственно.
      Версия 1.0 почти нигде сейчас не используется. Кроме <b>C#</b> генерация <b>MSIL</b>
      кода осуществляется также с языков <b>Managed C++</b> (расширение от Microsoft
      языка <b>C++</b> для <b>CLR</b>), Visual Basic, Visual J#, входящих в упоминавшиеся
      пакеты Visual Studio. В силу ориентации на <b>CLR</b> имеется возможность удобного
      сочетания любого из названных языков. Кроме того, имеется возможность вызова
      непереносимого кода, написанного под какую-либо конкретную платформу.
      Как правило, это реализуется через вызов из <b>Managed C++</b> кода,
      написанного на <b>Unmanaged C++</b> (обычный <b>C++</b>), хотя такая возможность
      имеется и в других языках.
    </p>
		<p>
      Программы, написанные на <b>C++</b>, также можно перенести на разные платформы,
      но для этого приходится перекомпилировать программу. При этом появляется проблема
      компиляции программы на разных компиляторах для разных платформ.
      Для программ, поставляющихся с исходным кодом, это является только техническим ограничением.
      Но для коммерческих программ, поставляемых в виде бинарной программы,
      это является практически непреодолимым ограничением,
      если разработчик не имеет версии для нужной платформы.
    </p>
		<p>
      Если говорить о переносимости программ, написанных под .NET, то несмотря
      на перспективность <b>CLR</b>, эти программы, в основном, ориентированы только на Windows.
      Насколько я знаю, разрабатывается Open Source проект <b>DotGNU</b>
      (<a href="http://www.dotgnu.org/" target="_blank">www.dotgnu.org</a>) для поддержки .NET на Linux, но
      сведений о его реальном использовании у меня нет.
    </p>
		<p>
			<i>Павел Потапов aka Scavenger (выпуск 2003 СМ)</i>
		</p>
		  <a href="#top">Вернуться в начало</a>
		<p/>
	</body>
</html>
