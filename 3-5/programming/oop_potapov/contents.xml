<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/index.xsl"?>
<!DOCTYPE html SYSTEM "/contents.dtd">
<html> 
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<link href="statmod.css" rel="stylesheet" type="text/css"/>
		<title>ООП: некоторые Принципы Разработки Программ на C++</title>
	</head>
	<body>
		<a name="top"/>
		<h2>
		  <a name="intro"/>ООП: некоторые принципы разработки программ на C++</h2>
    <h3>
      Введение</h3>
    <p>
      В данной статье описывается ряд принципов разработки программ в объектно-ориентированном стиле. Под разработкой понимается не только написание программного кода, но и проектирование структуры программы или ее части, согласно требованиям, к ней предъявляемым. Эти требования основаны как на личном опыте профессионалов, так и на литературе. Целью статьи является изложение правил, следование которым позволяет соблюдать эти требования. </p>
    <p>
      Статья в первую очередь предназначена для тех, кто недавно познакомился с объектно-ориентированным
      программированием (ООП), в частности с программированием на C++. Основные требования
      и принципы разработки излагаются в ней без детального анализа, но они могут послужить
      хорошим ориентиром для людей, начинающих программировать. С одной стороны, можно
      придерживаться сразу всех нижеизложенных правил, но, с другой стороны, набор этих правил не является чем-то незыблемым, его можно и нужно адаптировать в соответствии
      со своими нуждами.</p>
    <h3>
      Требования к разработке</h3>
    <p>
      Основная цель разработки &ndash; это получение программы, с некоторым набором функциональности.
      Естественно, что сразу получить готовую программу невозможно.
      Поэтому приходится
      делать все постепенно, при этом хочется быть уверенным, что все сделанное работает правильно.
      Отсюда появляется первое требование  &ndash; 
      <span class="interesting">как можно чаще доводить программу до рабочего состояния</span>.
      В идеале это означает, что программа должна всегда компилироваться, запускаться
      и выполнять все действия правильно. Но это в идеале, в реальности даже готовые версии
      не работают так, как предполагается. Как правило, всегда имеется ряд неисправленных
      ошибок и недостатков. Поэтому первое, что приходится откинуть (но к чему необходимо
      стремиться) &ndash; это правильная работа программы. Единственное, что должно выполняться
      почти всегда &ndash; программа не должна совершать фатальных ошибок, говоря на сленге
      программистов, падать.
      В гораздо более редких случаях программу невозможно запустить. И еще реже
      &ndash; скомпилировать. Компиляция &ndash; это первая проверка на ошибки в программе, и я стараюсь
      компилировать код как можно чаще, а также проверять, что программа запускается.</p>
    <p>
      Хочется того или нет, но в программу часто закрадываются ошибки, которые приходится
      искать и исправлять. При этом возникает необходимость в обращении к коду, написанному
      ранее. И хорошо, если ты имел дело с этим кодом на прошлой неделе, но часто приходится
      искать ошибки в коде написанном раньше. Отсюда возникает следующее требование: <span class="interesting">
        поиск ошибок в коде должен быть как можно легче</span>.</p>
    <p>
      Как и большинство людей, я &ndash; лентяй и не люблю много работать. Поэтому я стараюсь
      писать только тот код, который нужен в данный момент. Это оборачивается тем, что
      приходится изменять уже написанный код. Конечно, с одной стороны это &ndash; минус, но
      с другой оказывается, что только в редкие моменты можно предусмотреть все, что требуется,
      сразу, и часто код, написанный "на будущее", приходится переписывать. На самом деле,
      этот подход я позаимствовал из экстремального программирования
      (<a href="http://en.wikipedia.org/wiki/Extreme_Programming">XP &ndash; eXtreme Programming</a>),
      где вся разработка ведется подобным образом. Итак, получаем еще одно требование
      &ndash;
      <span class="interesting">код должен быть расположен к изменениям</span>.</p>
    <p>
      Подводя итоги, перечислим основные требования:</p>
    <ul>
      <li>Программа должна находиться в рабочем состоянии как можно чаще. То есть компилироваться, запускаться
        и правильно работать. </li>
      <li>Поиск ошибок в коде должен быть как можно легче.</li>
      <li>Код должен быть написан так, чтобы его легко было изменять. </li>
    </ul>
    <h3>
      Правила разработки</h3>
    <p>
      Далее я сформулирую правила, которых придерживаюсь при написании программ:</p>
    <ul>
      <li><a href="#penpaper">Главный инструмент разработчика &ndash; ручка и бумага</a>
      </li><li><a href="#understand">Код должен быть понятен</a>
      </li><li><a href="#couplingcohesion">Слабая степень связности и сильная степень зацепления</a>
      </li><li><a href="#checkin">Проверка предположений о входных параметрах функций</a>
      </li><li><a href="#smallstep">Изменения маленькими шажками</a>
      </li><li><a href="#encapsulate">Инкапсуляция данных</a>
      </li><li><a href="#inheritaggr">Наследование и агрегирование</a>
      </li><li><a href="#initialize">Корректная инициализация объектов</a>
      </li><li><a href="#enchanges">Инкапсуляция изменений</a>
      </li><li><a href="#refactor">Рефакторинг</a>
      </li></ul>
    <h4><a name="penpaper">
      Главный инструмент разработчика &ndash; ручка и бумага</a></h4>
    <p>
      Под этим я подразумеваю то, что всегда надо иметь представление о том, что вы собираетесь
      делать и зачем. Это всегда является причиной написания того или иного кода. Поэтому
      прежде, чем начать писать код, необходимо ясно себе представить то, что надо сделать.
      Большинство людей лучше всего воспринимают визуальную информацию, поэтому рисунки
      &ndash; лучший способ получить представление о том, что хочется сделать. Как правило,
      я рисую и то, что должен увидеть пользователь, и то, что при этом должно происходить
      в коде программы. Одним из общепринятых стандартов для последнего является UML.
      Правильно нарисованная структура облегчает понимание и написание нового кода. Это приводит
      к упрощению структуры кода, поиска ошибок и внесения изменений в код.</p>
    <h4><a name="understand">
      Код должен быть понятен</a></h4>
    <p>
      Сама по себе цель этого правила понятна, но часто не совсем ясно, как этого достичь.
      Следующие правила написания кода я считаю наиболее важными:</p>
    <p>
      1) Стиль форматирования кода должен быть один. Если все время
      придерживаться выбранного стиля, то структура кода будет видна лучше.</p>
    <p>
      2) Все идентификаторы в коде должны выражать смысл понятий, стоящих за ними. Например,</p>
    <code>
      class Car<br />
      {<br />
      public:<br />
      &nbsp;&nbsp;void IncreaseSpeed(double acceleration);<br />
      };</code><p>
      гораздо понятней, чем</p>
    <code>
      class MyClass<br />
      {<br />
      public:<br />
      &nbsp;&nbsp;void Method1(double);<br />
      };</code><p>
      3) Объявление и реализация каждого класса должны находиться в отдельных файлах.
      То есть в одном *.h или *.cpp файле описывается только один класс. Иногда от одного
      базового класса наследуется несколько классов, переопределяющих одну единственную
      функцию, в этом случае велик соблазн поместить все классы в один файл, но я все
      равно предпочитаю придерживаться данного правила. В крайнем случае можно сделать
      две пары файлов: одна для базового класса, другая &ndash; для производных.</p>
    <h4><a name="couplingcohesion">
      Слабая степень связности и сильная степень зацепления</a></h4>
    <p>
      Это одно из главных правил объектно-ориентированного программирования. По английски
      оно звучит, как "low coupling, high cohesion".</p>
    <p>
      Связность (<a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)">coupling</a>) &ndash;
      это взаимная зависимость <strong>реализации</strong> классов между собой,
      то есть количество изменений, которые надо внести в классы при изменении другого
      класса. Слабая связность означает, что изменения, вносимые в один класс
      повлекут за собой небольшие изменения в другие классы. Например, если в классе есть
      публичная переменная (public), широко используемая в программе, то изменение типа
      этой переменной повлечет за собой изменение большой части кода программы. Уменьшить
      эту связность можно за счет реализации методов доступа (Set... и Get...). В большинстве
      случаев это позволит изменить только методы доступа и при необходимости добавить
      новые.</p>
    <p>
      Зацепление (<a href="http://en.wikipedia.org/wiki/Cohesion_(computer_science)">cohesion</a>) &ndash;
      это степень общности <strong>обязанностей</strong> конкретного классов, то есть количество
      типов задач, выполняемых классом. Слабое зацепление означает,
      что ни в одном месте программы нет смысла использовать все методы класса. Например,
      в класс, который осуществляет загрузку/выгрузку данных, не имеет смысла добавлять
      метод для расчета какой-либо сложной функции. Лучше сделать второй класс, и при
      необходимости использовать его в первом (при этом можно создать его локально в нужном
      месте).</p>
    <p>
      Данное правило означает, что каждый класс должен быть сфокусирован на решении одной
      конкретной задачи и иметь ровно столько связей с другими классами, сколько нужно
      для решения этой задачи.</p>
    <h4><a name="checkin">
      Проверка предположений о входных параметрах функций</a></h4>
    <p>
      При разработке каждой функции явно или не явно делаются какие-то предположения о
      входных параметрах. Все эти предположения следует проверять всегда, так как предположения
      о входных параметрах могут не выполнятся, например, в случае какой-либо ошибки в
      месте вызова функции. Часто в функции передаются указатели на какие-либо объекты.
      В этом случае необходимо выполнить проверку на нулевой указатель даже в том случае,
      если есть уверенность в том, что в местах вызова этот указатель всегда не нулевой.</p>
    <p>
      Необходимо обрабатывать случаи невыполнения предположений о входных параметрах.
      Часто это простой возврат из функции. А в тех случаях, когда предположения должны
      быть выполнены всегда, я еще рекомендую пользоваться макросами <strong>ASSERT</strong>
      или <strong>VERIFY</strong>.
      Иногда для обработки таких ситуаций используются исключения, но я не рекомендую
      их использовать, если вы не знаете точно, что вы с ними будете делать. Наличие выбрасываемых
      исключений обязывают пользователей функции их ловить в любом случае, что в большинстве
      случаев увеличивает количество кода (и ошибок).</p>
    <h4><a name="smallstep">
      Изменения маленькими шажками</a></h4>
    <p>
      В процессе создания программы приходится писать много нового кода. При этом в коде
      появляется много различных ошибок. Для того чтобы исправить эти ошибки, приходится
      много трудится. Для упрощения этого процесса лучше двигаться постепенно, вносить
      необходимые изменения небольшими частями, каждый раз проверяя правильность реализации
      уже готовых частей. Таким образом удается быстрее локализовать ошибки. Следует помнить,
      что первым об ошибке может сообщить компилятор, поэтому компилировать код следует
      как можно чаще. А при успешной компиляции иногда следует запускать программу и проверять,
      что старая функциональность работает.</p>
    <h4><a name="encapsulate">
      Инкапсуляция данных</a></h4>
    <p>
      <a href="http://ru.wikipedia.org/wiki/Инкапсуляция_(программирование)">Инкапсуляция данных</a>
      &ndash; это один из основных принципов объектно-ориентированного программирования.
      Инкапсуляция данных &ndash; это изолирование данных объекта от внешнего мира. Очень важно,
      что объект всегда должен находится в корректном состоянии. Это обеспечивается, в
      частности, тем, что доступ к данным объекта имеет только сам объект, так как в этом
      случае можно проконтролировать правильность данных. Стоит обратить особое внимание,
      что классы, наследуемые от базового, по отношению к нему являются почти такими же
      внешними, что и остальные, за исключением большего уровня доступа к объекту. Поэтому
      я рекомендую делать все поля <span class="interesting">private</span> и обеспечивать
      к ним доступ через функции. Это упрощает внесение изменений в поля объекта, так
      как для обеспечения корректности работы достаточно переписать только функции доступа.</p>
    <h4><a name="inheritaggr">
      Наследование и агрегирование</a></h4>
    <p>
      Есть два способа использования уже существующего класса в объекте: в качестве базового
      класса (<a href="http://ru.wikipedia.org/wiki/Наследование_(программирование)">наследование</a>),
      и в качестве поля класса (агрегирование).
      Наследовании базового класса предполагает изменение и/или расширение его функциональности, а часто еще
      и использование наследника вместо базового класса.
      Агрегирование предполагает использование готового класса без изменения функциональности.
      Агрегирование накладывает меньше ограничений на последующие изменения класса,
      поэтому при прочих равных условиях я рекомендую использовать именно его. При выборе между наследованием и агрегированием
      следует задать себе вопрос: "Является ли новый класс частным случаем старого или
      старый является свойством первого?". Например, при реализации двумерного массива,
      через одномерный, следует предпочесть агрегирование. Так как несмотря на то, что
      двумерный массив будет храниться, как одномерный, одномерный массив будет его свойством,
      а не сущностью.</p>
    <h4><a name="initialize">
      Корректная инициализация объектов</a></h4>
    <p>
      Очень важно, чтобы объект находился в корректном состоянии на протяжении всей своей
      жизни (от момента создания до момента удаления). Поэтому важно правильно инициализировать
      объект. Если для создания объекта в корректном состоянии необходимы какие-либо данные,
      то лучше всего передать их в конструкторе объекта. Это гарантирует то, что вы не
      забудете передать данные для правильной инициализации объекта. Если же такой возможности
      нет, то необходимо учитывать это при написании реализации класса, в каждом методе
      должна быть проверка на то, что класс находится в корректном состоянии.</p>
    <h4><a name="enchanges">
      Инкапсуляция изменений</a></h4>
    <p>
      С изменяющимися сущностями чрезвычайно сложно работать. Для упрощения работы лучше
      создать отдельный класс, инкапсулирующий эти изменения. Классическим примером можно
      считать разделяемые объекты с подсчетом ссылок и умные указатели, которые инкапсулируют
      изменение количества ссылок на такие объекты.</p>
    <h4><a name="refactor">
      Рефакторинг</a></h4>
    <p>
      Рефакторингом называется внесение изменений в код без изменения его функциональности.
      Обычно рефакторинг применяется перед реализацией новой функциональности, которая
      требует изменений в существующем коде. Основное правило: сначала изменить существующий
      код под новые потребности, проверить его правильность, а потом вносить новые изменения.
      Такое разделение упрощает проверку правильности работы новой функциональности, разделяя
      вносимые изменения.</p>
    <p>
      Иногда рефакторинг проводится просто для упрощения структуры программы, но это следует
      делать осторожно, так как в некоторых случаях риск что-либо испортить может быть
      слишком велик.</p>
    <h3>
      <a name="literature"></a>
      Список литературы</h3>
    <ol>
      <li>Приемы объектно-ориентированного проектирования. Паттерны проектирования.
          Гамма Э., Хелм Р., Джонсон Р., Влиссидес Д.</li>
      <li>Экстремальное программирование. Бек К.</li>
      <li>Язык программирования C++. Страуструп Б.</li>
      <li>Рефакторинг: улучшение существующего кода.
          Фаулер М., Бек К., Брант Д., Робертс Д., Апдайк У.</li>
      <li>Эффективное использование STL. Мейерс С.</li>
      <li>Наиболее эфективное использование STL. Мейерс С.</li>
    </ol>
    <h3>
      <a name="links"></a>
      Полезные ссылки:</h3>
    <ol>
      <li><a href="http://www.codeproject.com">CodeProject</a> &nbsp;&ndash; большой англоязычный портал.</li>
      <li><a href="http://www.rsdn.ru">RSDN</a> &nbsp;&ndash; известный русскоязычный ресурс.</li>
    </ol>
    <p>
      <i>Павел Потапов aka <a href="http://statmod.ru/forum/profile.php?mode=viewprofile&amp;u=15">Scavenger</a> (выпуск 2003 СМ)</i>
    </p>
		  <a href="#top">Вернуться в начало</a>
		<p/>
	</body>
</html>
